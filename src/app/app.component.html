<!-- TASK LIST:

  1 - Forms 
      - Reactive Form to update data ([formGroup]="someForm" <input formControlName="name"> (ngSubmit)="onSubmit() name: new FormControl('')" / name = new FormControl('') [formControl]="name" / FormBuilder) - suitable for larger, complex forms
      - Template Driven Form to update data model - ([ngModel]) to bind form data to model <form #someForm="ngForm" (ngSubmit)="onSubmit()"- suitable for small forms
      - Input, two way data binding (ngModel) - <input ([ngModel])="object.name">
      - Form Validation using both reactive & template driven forms, much like html form validation
        - Template Driven Form Validation: (<input required>, <input minlength="2">, <input maxlength="10">, <input pattern="[a-z]+"). Validation message like this: <div *ngIf="name.invalid && (name.dirty || name.touched)><div *ngIf="name.errors?.required"><p>Name is required</p></div>"
        - Reactive Form Validation: someForm = new FormGroup({ name: new FormControl this.nameInput, Validators.required, Validation.minLength(4)}). Validation message like this: <div *ngIf="name.invalid && name.dirty || name.touched)><div *ngIf="name.errors?.required"><p>Name is required</p></div>"
      - (keyup) change detection concept can also be used to actively track changes to the data model and re-render the view up change
      - See reactive forms component in this project to see how to best implement a Reactive Form
      - Angular 14 new feature 'Typed Form' which apples TS types to Reactive Forms (https://blog.angular-university.io/angular-typed-forms/) 

      ** see reactive-forms component in this project to see best implementation of formGroup & form builder using validators 
      
      ** See best implementation of formGroup & form builder using validators in Reactive Angular repo. Also using formGroup & form builder & validators - https://github.com/clarkenewsh/reactive-angular-with-rxjs/blob/main/reactiveAngularCourseNotes.md

      Additional Learning Resource:
      - Angular Docs - https://angular.io/guide/reactive-forms
      - Angular Uni Blog Resource - https://blog.angular-university.io/tag/angular-forms/

  2 - Components / core directives
      - Angular Uni Blog Resource - https://blog.angular-university.io/tag/angular-core/
      - Angular docs - https://angular.io/guide/inputs-outputs & https://angular.io/guide/component-interaction

      - Text Interpolation from class properties values

      - Parent/Child components:
        - [course]="course" placed in the component declaration & @Input in the child component for data binding from parent to child component - define property in parent in, pass in to component declaration with attribute binding [course]=[course] and @Input inside child component ts file (use the interface type to declare in child component to make type safe) i.e @Input course: Course;

        - @Output new EventEmitter for event binding/emitting - child back up to parent

        - Native click events can be bubbled up from child to parent without using @Output, just need (click) in the component declaration

        - Custom events will need the @Output EventEmitter to bubble up -  define method in the parent component, name the event in the @Output in the child component ts file with typescript defined what it getting outputted, $event can be caught in the component declaration and then caught in the parent component as params as we used the $event & EventMiter
            
        - Example of custom events:

        ** App Component.ts 
          **catch course payload as course param using the $event and Event emitter 
          onCourseSelected(course:Course) {
            console.log("app comp - click event bubbled", course);
          }

        ** App Component.html
          **Catch course object payload using the $event emitter, pass the payload to the courseSelected() custom event. *Custom event is named the same as the @Output EventEmitter
          <course-card *ngFor="let course of courses; 
              index as i; 
              first as isFirst; 
              last as isLast;"
              [class.is-first]="isFirst" 
              [class.is-last]="isLast" 
              (courseSelected)="onCourseSelected($event)" 
              [course]="course" [cardIndex]="i + 1"
              [noImageTpl]="blankImage">

              <course-image [src]="course.iconUrl"></course-image>
          </course-card>

        ** Child Component.ts
          @Output() courseSelected = new EventEmitter<Course>();
            
          onCourseViewed() {
            console.log("card comp - button clicked")
            this.courseSelected.emit(this.course);
          }

        ** Child Component.html
          <button (click)="onCourseViewed()">View Course</button>

      - Structural Directives 
        - *ngFor, *ngIf, ngContainer (used when we need a div to conditionally render html structure), *ngSwitchCase elvis operator?
        - ng-container (this is how angular works under the hood when using *ngIf/*ngFor)
        - ng-container can be used instead of a div to apply conditional structural rendering (dont apply a div just to apply conditional rendering. ng-container should be used in this situation)
        - ng-container can also be used when using the async pipe to subscribe top Observables instead dof creating a extra div element to house the async pipe
        - *ngIf can be used in multiple ways - boolean expression on object (entire object is best practice as it will bypass the undefined object and still show the remaining course objects) or individual object property, custom function calls etc
        - With *ngFor all that it matters to determine if an element is shown or not is the truthiness of the expression passed to ngIf.
        - *ngIf can be used with an else 'else' can be used to display an error message were else is a ng-template with template variable using #templateVariableName as the else clause.
        - With ngIf, if an element is hidden then that element does not exist at all in the page. Unlike using css to hide an element but is still loaded in to the DOM.
        - *ngFor allows us to build data presentation lists and tables in our HTML templates.
        - Consuming Observable data with ngIf & the async pipe: Using *ngFor in a reactive pattern with Observable data we can use - <div *ngIf=”(currentOpenMenu$ | async) as currentOpenMenu””> observable which we can then use in the template {{currentOpenMenu}}. By using 'as' we set a variable that takes on the values of the currentOpenMenu$ observable and we then use this local as variable in the template. 

          Example Consuming Observable data with ngIf & the async pipe:
          
          <ng-container *ngIf="(courses$ | async) as courses">
              <div class="courses">
                  {{courses.length}}
              </div> 
          </ng-container>

        - index as i to index each item in the ngFor loop
        - first & last can be used with ngFor to get the first and last index of the for loop. We can then target them and use for styling for example.
          - first as isFirst; 
          - last as isLast;
        - ng-template to show error messages or replace course image, conditional html structure,
        - Angular Uni Blog Resource
          - https://blog.angular-university.io/angular-ngif/

            - Example:
              <ng-content select="course-image" *ngIf="course.iconUrl; else noImage">
                Course Img here using ng-content using content projection to show course image 
              </ng-content>

              **Instantiate template reference 
              <ng-template #noImage>
                <p class="warn">{{course.description}} has no image is available</p>
              </ng-template>
  
          - elvis operator? can be used to bypass an undefined object value or object property so that the rest of the course are still displayed
          - *ngSwitch can be used when we want to conditionally render more than two outcomes 
            Example ngSwitch:
            **[ngSwitch] attr & *ngSwitchCase / *ngSwitchDefault structural directive, used to show course level 
              <ng-container [ngSwitch]="course.category">
                <div class="course-category">
                <ng-container *ngSwitchCase="'BEGINNER'">
                  <div class="category" >
                  Beginner
                  </div>
                </ng-container>
                <ng-container *ngSwitchCase="'INTERMEDIATE'">
                  <div class="category" >
                  Intermediate
                  </div>
                </ng-container>
                <ng-container *ngSwitchCase="'ADVANCED'">
                  <div class="category" >
                  Advanced
                  </div>
                </ng-container>
                <div class="category" *ngSwitchDefault>
                  All Levels
                </div>
                </div>
              </ng-container>

      - Angular Uni Blog Resource - ngContent,ngContainer,ngTemplate, ngTemplateOutlet 
        - https://blog.angular-university.io/angular-ng-template-ng-container-ngtemplateoutlet/

      - Attribute, Class & Style directives for dynamic styling ([src], [title], [course], ngModel, ngClass, ngStyle, ngSwitch). 
      - Conditional classes and element styles can also be implemented using a method [ngClass]="cardClasses()" or [ngStyle]="cardStyles()" - (best practice & keeps the view clean) to check the key value pairs of the object are true/false, apply classes based out outcome.
      - Conditional style classes using [ngClass]
      - We can even apply a class to a html element if a member variables is true or false using [class.btn-primary] that is activating the btn-primary CSS class, effectively adding it to the button.

        - Example(using boolean value):
          <button class="btn" 
            [class.btn-primary]="true" 
            type="submit">Button
            </button>

        - We could also instead of adding true to the expression directly like above, we could use a member variable such is 'isSelected: boolean = false' and when this value is toggled the .btn-primary class could be turned on or of
          - Example (using boolean value from member variable):
          <button class="btn" 
            [class.btn-primary]="isSelected" 
            type="submit">Button
            </button>

            toggleSelected() {
            this.isSelected = !this.isSelected;
            }

        - We can also place the logic in the expression as below
          - Example (class logic inline expression):
            <h1>[ngClass]="{isActive ? 'activeClass' : '' }"</h1>

      - Angular Uni Blog Resource
        - https://blog.angular-university.io/angular-ngclass-ngstyle/

        Example conditional class (changing the class in a method): 
            <div [ngClass]="cardClasses()></div>

            ** add conditional styling to class - beginner courses true, apply 'beginner' class
            cardClasses() {
              if(this.course.category == 'BEGINNER') {
                return 'beginner';
              }
            }

        Example conditional style: 
          <div class="course-title" [ngStyle]="cardStyles()">
            {{cardIndex + ' ' + course.description}}
          </div>

          ** add conditional style to element
          cardStyles() {
            return {
              'text-decoration': 'underline'
            }
          }

      - Template Querying: viewChild & viewChildren - get a reference to the component 
        - If we want to write component initialization code that uses the references injected by @ViewChild, we need to do it inside the AfterViewInit lifecycle hook.
        - @ViewChild(CourseCardComponent) card: CourseCardComponent;
        - @ViewChild('container') containerDiv: ElementRef; View Child Decorator - get html element reference object
        - @ViewChild('container', {read: ElementRef}) containerDiv: ElementRef; - View Child Decorator - get html element in relation to the html DOM element (not component)
        - Angular Uni Blog Resource
          - https://blog.angular-university.io/angular-viewchild/
    

      - Content Projection
        - Content projection is about making configurable components. Customize the look and feel by adding extra content to a component using - <ng-content></ng-content>
        - When content is passed in to a component declaration, we can use <ng-content> within the components view to house & display that content
        - 'Select' can be used inside the <ng-content> to limit what content we would like the <ng-content> to house & display. Element selectors and css selectors can also be used to identify what content to project
        - Angular Uni Blog Resource
          - https://blog.angular-university.io/angular-ng-content/
          - https://blog.angular-university.io/angular-ng-template-ng-container-ngtemplateoutlet/
            
          EXAMPLE of Content Projection:

            ** Component declaration
              <course-card 
                [course]="course"
                (click)="onCourseSelected($event)">
                <img width="300" alt="angular logo" [src]="course.iconUrl">
              </courses-card>

            ** CourseCard Component view
              <div *ngIf="course">
                <div>
                  {{course.title}}
                </div>
                <ng-content select="img">'Image would be projected here'</ng-content>
                <p>{{course.description}}</p>
              </div>

        - @ContentChild('courseImage') image; can be used in the same was a ng-content but gives you a references to just that projected content within.
              - 'courseImage' is the template variable that we are targeting

      - Angular Templates (ng-template) can be used to provide alternative content block within a components view - For example if no course image show the ng-template content with blank image placeholder
         - Use template block to display error message if course object image (ng-content) is not available - using 'else', blankImage template variable to place a placeholder image in ng-content block
         - Angular Uni Blog Resource - ngContent,ngContainer,ngTemplate, ngTemplateOutlet 
          - https://blog.angular-university.io/angular-ng-template-ng-container-ngtemplateoutlet/
         
          EXAMPLE:
          ** CourseCardComponent.html

          <div *ngIf="course">
            <ng-template #blankImage>
              <p class="warn">{{course.description}} has no image is available</p>
              <img src="/assets/empty-image.png">
            </ng-template> 

            <ng-content select="course-image"
              <*ngIf="course.iconUrl; else blankImage">
                Course Img here using ng-content using content projection to show course image
            </ng-content>
          </div>

        - ngTemplate Instantiation with ngTemplateOutlet can be used to achieve the same as above but makes the ng-template block re-usable.
          EXAMPLE;
          ** appComponent.html
          <div class="courses" #container> 

            **Define ng-template with an input context 'let-courseName' (this enables reusability of the ng-template block error message)
            <ng-template #blankImage let-courseName="description">
              <p class="warn">{{courseName}} has no image is available</p>
              <img src="/assets/empty-image.png">
            </ng-template>

            **Instantiate ng-template using ngTemplateOutlet within ng-container (best practice to instantiate ng-template as an input param directly into the component as done below in course-card component [noImageTpl]="blankImage" '') 
            **Context variable used to access let-courseName="description" input context
            <ng-container *ngTemplateOutlet="blankImage; context: {description: course.description}"></ng-container> 

            <course-card *ngFor="let course of courses; 
              index as i; 
              first as isFirst; 
              last as isLast;"
              [class.is-first]="isFirst" 
              [class.is-last]="isLast" 
              (courseSelected)="onCourseSelected($event)" 
              [course]="course" [cardIndex]="i + 1"
              [noImageTpl]="blankImage">

              <course-image [src]="course.iconUrl"></course-image>
            </course-card>

          </div>

        - Templates can also be implemented using component inputs. Best practice to instantiate ng-template as an input param directly into the component as done below in course-card component [noImageTpl]="blankImage"
          - Instantiate ng-template using ngTemplateOutlet within ng-container (best practice to instantiate ng-template as an input param directly into the component as done below in course-card component [noImageTpl]="blankImage"
          - Angular Uni Blog Resource - ngContent,ngContainer,ngTemplate, ngTemplateOutlet 
             - https://blog.angular-university.io/angular-ng-template-ng-container-ngtemplateoutlet/

          EXAMPLE;
          **courseCardComponent.ts
            **Receive noImageTpl template as input variable
            @Input() noImageTpl: TemplateRef<any>
          
          **courseCardComponent.ts
          <div *ngIf="course">

          	<ng-content select="course-image" *ngIf="course.iconUrl; else noImage">
	            Course Img here using ng-content using content projection to show course image 
	          </ng-content>

            **Instantiate template reference that was passed in - noImageTpl 
              <ng-template #noImage>
                <ng-container *ngTemplateOutlet="noImageTpl; context:{description:course.description}"></ng-container>
              </ng-template>

              <div class="course-description">
                {{course.longDescription}}
              </div>

          </div>

          ** appComponent.html
          <div class="courses" #container>

            **Define ng-template with an input context 'let-courseName' (this enables reusability of the ng-template block error message)
            <ng-template #blankImage let-courseName="description">
              <p class="warn">{{courseName}} has no image is available</p>
              <img src="/assets/empty-image.png">
            </ng-template>

            <course-card *ngFor="let course of courses; 
              index as i; 
              first as isFirst; 
              last as isLast;"
              [class.is-first]="isFirst" 
              [class.is-last]="isLast" 
              (courseSelected)="onCourseSelected($event)" 
              [course]="course" [cardIndex]="i + 1"
              [noImageTpl]="blankImage">

              <course-image [src]="course.iconUrl"></course-image>

            </course-card>
          </div>

      - Template variables using, #name <input (click)="updateName(name.value)">

      - Custom Directives:
          - As well as Angular built in directives (ngStyle, ngClass, ngFor, ngIf) we can create Custom Directives that can be applied to components to provide the component with some functionally can be re-sued over several components. This saves us from writing the functionally in every component as the directive is re-usable. We can just create the logic in a directive file and pass it into a component. For example we could have a fade-in fade-out custom directive. The functionally of this directive would be created inside a fadeOut.directive.ts file and this could then be placed into any component by adding the name of the directive inside the component declaration i.e <app-some-component fadeOut> were fadeOut is the custom directive. In the case of DTO we have a appMapWrapper directive & Toms draggable-slide directive used for Showcases. 

          - We can create several Custom Directives such as Attribute or Structural Directives which gives us some re-usable functionality that we can use throughout any component we wish.

          - Custom Directives provide custom features that we can use inside of a component to modify behavior, style and structure etc.

          - Use case is to make re-usable custom directives class, attribute, structural and events that can then be applied throughout to app by adding to components.

          - With Custom Attribute Directives @HostListener is used to interact with native DOM Events on elements - i.e mouseover / mouseleave / (use case - create custom events).

          - With Custom Structural Directives private templateRef: TemplateRef<any> & private viewContainer: ViewContainerRef which need to be used in the constructor as TemplateRef helps you get to the <ng-template> contents and ViewContainerRef accesses the view container. We must use <ng-template *customStructuralDirective> with the custom structural directive the * directive for this to work. More info on this in examples below.

          - Custom Directives can be created with the CLI using 'ng generate directive fadOut' & 'stored in 'directives folder'.

          - Custom Directives Learning Resource:
            - Angular Docs - https://angular.io/guide/attribute-directives
            - Angular Docs - https://angular.io/guide/structural-directives
            - Angular Guide - https://angular-training-guide.rangle.io/advanced-angular/directives/creating_an_attribute_directive
            - Angular Guide - https://angular-training-guide.rangle.io/advanced-angular/directives/creating_a_structural_directive
            - Decoded Frontend Video - https://www.youtube.com/watch?v=07CaGlbMPbw&list=PLX7eV3JL9sfmuWwKB2zP_1w7NhLVN10d7&index=1

          - Custom 'Attribute Directives' can be be used to pass values such as css classes to a element within a component that that directive is applied to. Import ElementRef from @angular/core. ElementRef grants direct access to the host DOM element through its nativeElement property. Add ElementRef in the directive's constructor() to inject a reference to the host DOM element, the element to which you apply appHighlight. Then add logic to the HighlightDirective class that sets the background to yellow. In the below example Angular creates an instance of the HighlightDirective class and injects a reference to the <p> element into the directive's constructor, which sets the <p> element's background style to yellow.
            
            - Example (Custom Directive using attribute and ElementRef):
              > highlight.directive.ts
              import { Directive, ElementRef } from '@angular/core';

              @Directive({
                selector: '[appHighlight]'
              })
              export class HighlightDirective {
                  constructor(private el: ElementRef) {
                    this.el.nativeElement.style.backgroundColor = 'yellow';
                  }
              }

              > app.component.html
              <p appHighlight>Highlight me!</p>

          
          - Custom 'Attribute Directives' can also set values based upon user events such as click, onMouseLeave, onMouseEnter. We can for example  detect when a user mouses into or out of the element and to respond by setting or clearing the highlight color. First we need to import Import HostListener from '@angular/core'. Add two event handlers that respond when the mouse enters or leaves, each with the @HostListener() decorator. Then we can subscribe to events of the DOM element that hosts an attribute directive, the <p> in this case, with the @HostListener() decorator. @HostListener is used to interact with native DOM Events on elements - i.e mouseover / mouseleave / (use case - create custom events). The example below shows how a background color appears when the pointer hovers over the paragraph element and disappears as the pointer moves out.
            
            - Example Custom Structural Directives (Custom Directive using user events & HostListener):
              > highlight.directive.ts
              import { Directive, ElementRef, HostListener } from '@angular/core';

              @Directive({
                selector: '[appHighlight]'
              })
              export class HighlightDirective {

                constructor(private el: ElementRef) { }

                @HostListener('mouseenter') onMouseEnter() {
                  this.highlight('yellow');
                }

                @HostListener('mouseleave') onMouseLeave() {
                  this.highlight('');
                }

                private highlight(color: string) {
                  this.el.nativeElement.style.backgroundColor = color;
                }

              }

              > app.component.html
              <p appHighlight>Highlight me!</p>

          - Custom Attribute Directives we can pass values into the custom attribute directive. We will use the above example of setting the highligh color while applying the HighlightDirective. First we import Input from @angular/core. We then add the appHighlight @Input() property in the directive. The @Input() decorator adds metadata to the class that makes the directive's appHighlight property available for binding. In the app.component.ts file we add a color property to the AppComponent (color:string = 'yellow';). To simultaneously apply the directive and the color, use property binding with the appHighlight directive selector, setting it equal to color. This is much like what we are doing in DTO with map-wrapper. 

               - Example (pass values into the custom attribute directive):
               > highlight.directive.ts
               @Input() appHighlight = '';

               > app.component.ts
               export class AppComponent {
                color:string = 'yellow';
              }
              
              > app.component.html 
              <p [appHighlight]="color">Highlight me!</p>

          - Custom 'Structural Directives' are directives which change the DOM layout by adding and removing DOM element. If we would like a re-usable structural directive this is were creating a custom structural directive is useful. For example we have a Custom 'Structural Directives' where we could show/hide html elements based on some value being true/false. 

          - With Custom Structural Directives we use private templateRef: TemplateRef<any> &private viewContainer: ViewContainerRef need to be used in the constructor as TemplateRef helps you get to the <ng-template> contents and ViewContainerRef accesses the view container. We must use <ng-template *customStructuralDirective> with the custom structural directive the * directive for this to work. We also use the @Input decorator in the directive to pass some value such a true/false that will communicate to the two components. more view

          - To change the DOM layout when using Custom Structural Directives we must use TemplateRef & ViewContainerRef in our structural directive. 'TemplateRef' represents an embedded template that can be used to instantiate embedded views. 'ViewContainerRef' represents a container where one or more views can be attached. We must instantiate them using dependency Injection in the custom directive. To add a host element to the DOM we need to call 'createEmbeddedView()' which is a method of viewContainerRef. We can then clear a view container using 'clear()' which is a method of ViewContainerRef. See example below.

          - Example Custom Structural Directive: 
            **ngx-unless.directive.ts file
            import { Directive, EmbeddedViewRef, TemplateRef, ViewContainerRef, Input } from '@angular/core';

            @Directive({
              selector: '[ngxUnless]'
            })
            export class NgxUnlessDirective {

              visible = false;

              > Inject custom directive templateRef & ViewContainerRef
              constructor(
                private templateRef: TemplateRef<any>,
                private viewContainer: ViewContainerRef
              ) { }

               > If condition false, instantiate template using EmbeddedViewRef & templateRef, else remove ng-template from the UI. Visible conditional used if visible flag is set to false (use case: if already rendered to UI stop it duplicating ng-template).

              @Input()
              set ngxUnless(condition: boolean) {
                if(!condition && !this.visible) {
                  this.viewContainer.createEmbeddedView(this.templateRef);
                  this.visible = true;
                }
                else if(condition && this.visible) {;
                  this.viewContainer.clear()
                  this.visible = false;
                }
              }

            }
            
            > app.component.html
            <ng-template>
              <course-image 
                [src]="course.iconUrl" 
                *ngxUnless="!course.iconUrl">
              </course-image>
            <ng-template>

          - Examples, see links:  
              - https://github.com/clarkenewsh/angular-core-deep-dive-2-directives/blob/main/src/app/app.component.html
              - https://github.com/clarkenewsh/angular-core-deep-dive-2-directives/blob/main/src/app/directives/highlighted.directive.ts
              - https://github.com/clarkenewsh/angular-core-deep-dive-2-directives/blob/main/src/app/directives/ngx-unless.directive.ts

          - @HostBinding can be used to apply directive to DOM elements. Apply highlighted directive to className DOM property using @HostBinding (must be a known DOM property)

          - Apply to DOM attr directly instead of DOM Property

          - @HostListener is used to interact with native DOM Events on elements - i.e mouseover / mouseleave / (use case - create custom events)

          - Can also used to emit custom using '$event' .

            - EXAMPLE Custom Attribute Directive (Udemy Course):
            ** app.component.html
            Custom structural directive - *ngxUnless (does the opposite to *ngIf) if the value is falsey 
              Custom structural directives can be implemented as below 
            <ng-template [ngIf]="courses[0]" let-course>
              <div class="courses salmon-theme">

              Custom attribute directive created 'highlighted' and applied as host element to the course-card component -->
              <!-- Custom event directives can also be created (toggleHighlighted)="onToggle($event)-->
              <!-- Can export a custom directive using template variable and #highlighter="hl" and assign it the expression as hl (exportAs: 'hl' saved in directives.ts file). Can then be used as so <div class="course-description" (dblclick)="highlighter.toggle()">  -->
              <!-- Custom structural directive - *ngxUnless (does the opposite to *ngIf) if the value is falsey 

              <course-card highlighted #highlighter="hl"
                (toggleHighlight)="onToggle($event)"
                (courseSelected)="onCourseSelected($event)"
                [course]="course">
                
                > *ngx-unless used as a custom structural directive to always show the course image, unless the iconUrl property is falsey (logic in the ngx-unless structural directive file)
                <course-image 
                  [src]="course.iconUrl" 
                  *ngxUnless="!course.iconUrl">
                </course-image>

                <div class="course-description" 
                  (dblclick)="highlighter.toggle()">
                  {{ course.longDescription }}
                </div>

              </course-card>

          </div>
          </ng-template>

            ** highlighted.directive.ts file
            @Input('highlighted')
            isHighLighted = false;

            **@HostListener is used to interact with native DOM Events i.e mouseover / mouseleave (can also use $event to emit the event)
              @Output()
              toggleHighlight = new EventEmitter();

            @HostListener('mouseover', ['$event'])
            mouseOver($event) {
              console.log($event);
              this.isHighLighted = true;
              this.toggleHighlight.emit(this.isHighLighted);
            }

            @HostListener('mouseleave')
            mouseLeave() {
              this.isHighLighted = false;
              this.toggleHighlight.emit(this.isHighLighted);
            }

            toggle() {
              this.isHighLighted = !this.isHighLighted;
              this.toggleHighlight.emit(this.isHighLighted);
            } 

  - View Encapsulation: concept is what happens under the hood when we have a css file scoped to an individual component   
      - :host can be used to app style the the host component 
      - ::ng-deep used to bypass view encapsulation (use case is to style elements within a component that have used content projection)
      - :host-context Modifier 
      - Bypass the feature encapsulation using: ViewEncapsulation.None 

  3 - HTTP Client
      - HttpClient service 
      - GET, POST, PUT, DELETE 
      - Async pipe as a solution to unsubscribe from a http observable (reduce memory leak)
      - Observables & RxJs
      - Observables in service
      - Subscribe() in component class
      - Error handling using pipe, tap & catchError in service
      - In Memory Data Service for fake REST API Backend
      - Service methods to speak with backend, component methods to update class properties and UI
      - Async pipe - A better way of passing Observable data to a view
      - Using Dependency Injection to provide services to components
      - Angular Uni Blog Resource
            - https://blog.angular-university.io/angular-http/

        - Example HTTP GET request: 

        http option headers (used for update, add, delete & api key ):
        httpOptions = {
          headers: new HttpHeaders({ 'Content-Type': 'application/json' })
        };

        ***SOLUTION 1 (Angular docs example with error handling)
        Service file (responsible for communication with http protocol / backend)
        getData():Observable {
          return this.http.get('https://someurl.com')
          .pipe(catchError (
            (error) => {
              console.log(error);
              return throwError('Error')
            }
          ));
        }

        Component file (responsible for updating class properties & the UI)
        ngOnInit() {
          this.dataService.getData().subscribe((res) => {
            console.log(res);
          })
        }


        ***SOLUTION 2 (Angular University example)
        // Call http service upon component initialization
          ngOnInit() {

            this.http.get('/api/courses')
            .subscribe(
              val => console.log(val);
            );
          }

        ***SOLUTION 2 with custom params (Angular University example)
          // Call http service upon component initialization
            ngOnInit() {

              // Set custom params (first page, first 10 courses)
              const params = new HttpParams()
              .set("page", "1")
              .set("pageSize", "10");

              this.http.get('/api/courses', {params})
              .subscribe(
                courses => this.courses = courses;
              );
            }

           ***SOLUTION 3 - Defining Observable as a variable and use the async pipe to subscribe to observable (best practice) 
              // Define courses Observable - value returned, array of courses
              courses$: Observable<Course[]>

              // HTTP Get request using the course Observable variable courses$ : Observable<Course[]>
              this.courses$ = this.http.get<Course[]>('/api/courses', {params});

              // In component - Take courses Observable and subscribe to it using the async pipe (async pipe will take take of unsubscribing from the Observable when component gets destroyed) 
              <div class="courses" *ngIf="courses$ | async as courses">
                <course-card *ngFor="let course of courses"
                            [course]="course">

                  <course-image [src]="course.iconUrl"></course-image>

                </course-card>

              </div> 


               ***SOLUTION 4 - Load courses through a coursesService, loadCourses() function and call the function in the onInit() app component. Use async pipe in courses component the same way.

              // Call http service upon component initialization
              ngOnInit() {
            
                console.log(this.coursesService);
            
                // Call the loadCourses function using the coursesService
                this.courses$ = this.coursesService.loadCourses();
              }
              
              ** CourseService
              loadCourses(): Observable<Course[]> {
                // Set custom params (first page, first 10 courses)
                const params = new HttpParams()
                .set("page", "1")
                .set("pageSize", "10");
            
                // HTTP Get request using the course Observable variable courses$ : Observable<Course[]>
                return this.http.get<Course[]>('/api/courses', {params});
              } 


              EXAMPLE HTTP PUT REQUEST(top to bottom thread of execution):

              ** CourseCardComponent
              @Output('courseChanged')
              courseEmitter = new EventEmitter<Course>();

              // Emit event, create copy of the course using object spread and overwrite the description property
              onSaveClicked(description:string) {
                this.courseEmitter.emit({...this.course, description});
              }

              ** App Component.html
              <div class="courses" *ngIf="(courses$ | async) as courses">
                <course-card *ngFor="let course of courses"
                             [course]="course"
                             (courseChanged)="save($event)">
                  <course-image [src]="course.iconUrl"></course-image>
            
                </course-card>
            
              </div>

              ** App Component.ts
              // Call courseService saveCourse method & subscribe to the observable
              save(course:Course) {
                this.coursesService.saveCourse(course)
                .subscribe(
                  () => console.log('Course saved!')
                );
              }
              
              ** coursesService
              // Save edited course - HTTP PUT
              saveCourse(course:Course) {
            
                const headers = new HttpHeaders()
                .set("X-Auth", "userId");
            
                // Get course id using $event value input and add course payload data
                return this.http.put(`/api/courses/${course.id}`, course, {headers});
              }

          *** ANGULAR UNIVERSITY CRUD SOLUTIONs -  USING RxJS

              **GET REQUEST:

              @Component({
              selector: 'app-root',
              template: `
                  <ul *ngIf="courses$ | async as courses else noData">
                      <li *ngFor="let course of courses">
                          {{course.description}}
                      </li> 
                  </ul>
                  <ng-template #noData>No Data Available</ng-template>
              `})

              export class AppComponent implements OnInit {
                  courses$: Observable<Course[]>;

                  constructor(private http:HttpClient) {
                  }

                  ngOnInit() {
                      this.courses$ = this.http
                          .get<Course[]>("/courses.json")
                          .map(data => _.values(data))
                          .do(console.log);
                  }
              }


              **GET REQUEST USING WITH PARAMS:

              import {HttpParams} from "@angular/common/http";

              const params = new HttpParams()
                  .set('orderBy', '"$key"')
                  .set('limitToFirst', "1");

              this.courses$ = this.http
                  .get("/courses.json", {params})
                  .do(console.log)
                  .map(data => _.values(data))



            **GET REQUEST USING USING 'REQUEST' API:

            @Component({
              selector: 'app-root',
              template: `
                  <ul *ngIf="courses$ | async as courses else noData">
                      <li *ngFor="let course of courses">
                          {{course.description}}
                      </li> 
                  </ul>
                  <ng-template #noData>No Data Available</ng-template>
            `})

            export class AppComponent implements OnInit {
                courses$: Observable<Course[]>;

                constructor(private http:HttpClient) {
                }

                ngOnInit() {
                  this.courses$ = this.http
                    .request(
                        "GET",
                        "/courses.json", 
                        {
                            responseType:"json",
                            params
                        })
                    .do(console.log)
                    .map(data => _.values(data));
                }
            }

            **PUT REQUEST:


      4 - Angular Change Detection

        - Change Detection Overview:
          - Change detection is the process through which Angular checks to see whether your application state has changed, and if any DOM needs to be updated. At a high level, Angular walks your components from top to bottom, looking for changes. Angular runs its change detection mechanism periodically so that changes to the data model are reflected in an app’s view. Change detection can be triggered either manually or through an asynchronous event (for example, a user interaction or an XHR completion).Change detection is a highly optimized performant, but it can still cause slowdowns if the application runs it too frequently.

          - Change detection is the process that allows Angular to keep our views in sync with our models / Change detection is a concept that angular rebuild a components view when a model data gets updated or changes. 
          - We can optimize the change detection mechanism by skipping parts of your application and running change detection only when necessary.
        
        - Default Change Detection Overview:
          - Default Change Detection is what is happening when we update data within models or update member variables which then checks every data expression in the template, its compares the current value of the property in the expression with the previous value. If the previous and current values are different Angular in the background will set isChanged to true which then triggers Angular to re-render the components view with the changed data. 

          - Default change detection is basically when Angular decides if the view needs to be updated by comparing all the template expression values before and after the occurrence of an event, for all components of the component tree

          - Best practice is to use default change detection where possible (where default change detection is causing performance issues, this is when using onPush Change Detection Strategy should be considered)

          - Default can be expensive (reduce performance) in a large applications when listening to changes to frequently throughout the applications component tree. Especially is the component hierarchy is large.

          - Default change detection: Angular decides if the view needs to be updated by comparing all the template expression values before and after the occurrence of an event, for all components of the component tree, from parent to child. If the component tree is large this is where default change detection can slow down the application.

          - To Summarize by default, Angular Change Detection works by checking if the value of template expressions have changed. This is done for all components. Also, by default, Angular does not do deep object comparison to detect changes, it only takes into account properties used by the template.

          - In summary default change detection: Change detection works by detecting common browser events like mouse clicks, HTTP requests, and other types of events, and deciding if the view of each component needs to be updated or not. Angular decides if the view needs to be updated by comparing all the template expression values before and after the occurrence of an event, for all components of the component tree

          - (keyup) is an another example of default change detection event in angular. It checks for changes in the data property model value upon each key stroke in input field (can be expensive as its checking the entire view and component for changes in data properties).

          - Example below for keyup change detection (function and component view):
        
            Edit Title: <input #courseTitle [value]="course.description" (keyup)="onTitleChanged(courseTitle.value)">
          
            > Change course title on keyup event
            onTitleChanged(newTitle: string) {
              this.course.description = newTitle;
            }

        - Change Detection Learning Resource: 
          - Angular Uni Blog resource 
            - https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/
            - https://blog.angular-university.io/onpush-change-detection-how-it-works/

          - Angular Docs
            - https://angular.io/guide/change-detection

          - Angular Guide 
            - https://angular-training-guide.rangle.io/change-detection


        - Optimizing Slow Computations Overview:
          - You can identify heavy computations with Angular DevTools’ profiler. In the performance timeline, click on a bar to preview a particular change detection cycle. This displays a bar chart, which shows how long the framework spent in change detection for each component. When you click on a component, you can preview how long Angular spent evaluating its template and lifecycle hooks.

          - There are several techniques to eliminate slow computations:
            1. Optimizing the underlying algorithm. This is the recommended approach; if you can speed up the algorithm that is causing the problem, you can speed up the entire change detection mechanism.

            2. Caching using pure pipes. You can move the heavy computation to a pure pipe. Angular will reevaluate a pure pipe only if it detects that its inputs changed, compared to the previous time Angular called it.

            3. Using memoization. Memoization is a similar technique to pure pipes, with the difference that pure pipes preserve only the last result from the computation where memoization could store multiple results.

            4. Avoid repaints/reflows in lifecycle hooks. Certain operations cause the browser to either synchronously recalculate the layout of the page or re-render it. Since reflows and repaints are generally slow, we want to avoid performing them in every change detection cycle.
          
          - Pure pipes and memoization have different trade-offs. Pure pipes are an Angular built-in concept compared to memoization, which is a general software engineering practice for caching function results. The memory overhead of memoization could be significant if you invoke the heavy computation frequently with different arguments.

          - Optimizing Slow Computations Learning Resource:
            - https://angular.io/guide/change-detection-slow-computations


  .     - Zone Pollution Overview:
          - Zone.js is a signaling mechanism that Angular uses to detect when an application state might have changed. It captures asynchronous operations like setTimeout, network requests, and event listeners. Angular schedules change detection based on signals from Zone.js

          - You can detect unnecessary change detection calls using Angular DevTools. Often they appear as consecutive bars in the profiler’s timeline with source setTimeout, setInterval, requestAnimationFrame, or an event handler. When you have limited calls within your application of these APIs, the change detection invocation is usually caused by a third-party library.

          - We can therefore run code outside the Angular zone to avoid unnecessary change detection calls using this strategy.

          - Since all asynchronous code executed from within Angular's zone can trigger change detection you may prefer to execute some code outside of Angular's zone when change detection is not required. To run code outside of Angular's context, NgZone provides a method aptly named runOutsideAngular. Using this method, Angular's zone will not interact with your code and will not receive events when the global zone becomes stable.

          - Third-party libraries commonly trigger unnecessary change detection cycles because they weren't authored with Zone.js in mind. Avoid these extra cycles by calling library APIs outside the Angular zone:

          - Zone Pollution Learning Resource:
            - https://angular-training-guide.rangle.io/zones
            - https://angular.io/guide/change-detection-zone-pollution


        - OnPush Change Detection Strategy:
          - JavaScript, by default, uses mutable data structures that you can reference from multiple different components. Angular runs change detection over your entire component tree to make sure that the most up-to-date state of your data structures is reflected in the DOM. Change detection is sufficiently fast for most applications. However, when an application has an especially large component tree, running change detection across the whole application can cause performance issues. You can address this by configuring change detection to only run on a subset of the component tree. If you are confident that a part of the application is not affected by a state change, you can use OnPush to skip change detection in an entire component subtree.

          - OnPush change detection: this works by detecting if some new data has been explicitly pushed into the component, either via a component input or an Observable subscribed to using the async pipe. When using event emitters onPush change detection works the same as default change detection (its only when we directly mutate @Input values from say the parent component that onPush does not work when mutating the data directly).

          - OnPush change detection instructs Angular to run change detection for a component subtree only when:
            1. The root component of the subtree receives new inputs as the result of a template binding. Angular compares the current and past value of the input with ==

            2. Angular handles an event (e.g. using event binding, output binding, or @HostListener) in the subtree's root component or any of its children whether they are using OnPush change detection or not.

          - OnPush change change detection is more efficient but trickier to use as you cant directly mutate the data directly as its not actively looking for changes in the view. It doesn't actively check changes in the data model that the view is outputting. You must copy the data model using the spread operator and then change the data model properties (much like in react).

          - When using OnPush detectors, then the framework will check an OnPush component when any of its input properties changes, when it fires an event, or when an Observable fires an event.

          - Although allowing for better performance, the use of OnPush comes at a high complexity cost if used with mutable objects. It might introduce bugs that are hard to reason about and reproduce. But there is a way to make the use of OnPush viable.

          - An Angular app implemented in a reactive style is much easier to refactor to use OnPush Change Detection - See Reactive Angular course, Section 6 for a video how this work. 

          - In Summary OnPush change detection: this works by detecting if some new data has been explicitly pushed into the component, either via a component input or an Observable subscribed to using the async pipe

          - We implement OnPush Change Detection in @Component Decorator as below;
            
          import { ChangeDetectionStrategy, Component } from '@angular/core';
              
            @Component({
                changeDetection: ChangeDetectionStrategy.OnPush,
              })
              export class MyComponent {}
          
          - OnPush change detection will only work with Observable data when using the async pipe. Not using the manual subscribe solution. 

          - Observables & OnPush: by using the async pipe with observables OnPush Change Detection works just fine when the observables emits a new value. If we subscribed manually in ngOnInit for example nPush would not work. Using async and OnPush is a great solution especially when the application is built in a reactive style with lots of observable data. So if we remember to subscribe to any observables as much as possible using the async pipe at the level of the template, we get a couple of advantages: we will run into much less change detection issue using OnPush.
          We will make it much easier to switch from the default change detection strategy to OnPush later if we need to.
          Immutable data and @Input() reference comparison is not the only way to achieve a high performant UI with OnPush: the reactive approach is also an option to use OnPush effectively

          - OnPush is a good option when handling a lot of data as it is better for performance s it does not check every component and view in the component tree, comparing previous and new values to detect if the data has changed.

          - How we can enforce OnPush Change Detection by enforcing Immutability: 
            - OnPush change detection can not mutate the data directly in the view (much like state on react). We must create a copy using the spread operator. This is then detected by OnPush Change Detection and the new copy of data with value changes will be updated. By utilizing Object Spread Operator, which is a fantastic way to ensure object immutability in our projects. It's important to, as often as possible, avoid any direct object property manipulation - as doing so can cause many issues when it comes to any of Angular's internal comparison by reference checks. For a high quality reactive application, immutability is key. Using this pattern we are taking full advantage of the "OnPush" change detection strategy and thus reducing the amount of work done by Angular to propagate changes and to get models and views in sync. This improves the performance of the application. Link to resource - https://angular-training-guide.rangle.io/change-detection/enforcing_immutability

          - If Angular handles an event within a component without OnPush strategy, the framework executes change detection on the entire component tree. Angular will skip descendant component subtrees with roots using OnPush, which have not received new inputs.

          - Attribute Decorator can be used when we have lots of inputs passed in to a component that will not require a change in data. So when having lots of @Input() property and we are sure than that data will not change over time we can use the @Attribute('type') private type: string in the constructor. Its great for performance optimization because when Angular runs through the change detection cycle if using the @Attribute decorator it will not check for changes on the @Input property.

          - Custom Change Detection can be implemented to tell angular to looks for changes in particular component when using OnPush change detection if we have not updated the @Input properties with by using the spread operator or when using observables without using the async pipe. Custom change detection is not best practice and should be used only when manually requesting changes frequently, that are expensive - i.e every 2seconds when dealing with lots of data continually.
          
          - Custom Change Detection is Implemented in constructor as private cd: ChangeDetectorRef. We then use ngDoCheck() lifecycle hook and inside this hook we check for changes using this.cd.markForCheck();
          
          -  Best way to implement custom change detection is by putting the checking logic in the ngDoCheck() lifecycle hook.

          - **IMPORTANT LINK** - See the below link to see how Angular skips component subtrees (parent, child, ancestors) when using default & OnPush Change Detection when mutating data with new data inputs & event handlers 
              - Angular Docs - https://angular.io/guide/change-detection-skipping-subtrees
          
          - Angular OnPush Change Detection Learning Resource:
            - https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/
            - https://blog.angular-university.io/onpush-change-detection-how-it-works/
            - https://angular.io/guide/change-detection-skipping-subtrees
            - https://angular-training-guide.rangle.io/change-detection


          - Example of Implementing OnPush change Detection (First mutating input data directly which doesnt work and then making a copy of @input() data, which does work with OnPush change detection).

            - First Example Using Default Change Detection
              > Home.component.ts
              @Component({
                selector: 'home',
                template: `
                <newsletter [user]="user" (subscribe)="subscribe($event)"></newsletter>
                <button (click)="changeUserName()">Change User Name</button>
            `})
            export class HomeComponent {

                user: User = {
                    firstName: 'Alice',
                    lastName: 'Smith'
                };

                constructor(private newsletterService: NewsletterService) {

                }

                subscribe(email:string) {
                    this.newsletterService.subscribe(email);
                }

                changeUserName() {
                    this.user.firstName = 'Bob'; << mutating the firstName of the user object directly 
                }

            }

            > Newsletter.component.ts
            @Component({
                selector: 'newsletter',
                template: `
            <fieldset class="newsletter">
                
                <legend>Newsletter</legend>
                
                <h5>Hello {{user?.firstName}},
                    enter your email below to subscribe:</h5>
                <form>
                    
                    <input #email type="email" name="email" placeholder="Enter your Email">
                  
                    <input  type="button" class="button button-primary" value="Subscribe"
                            (click)="subscribeToNewsletter(email.value)">
                </form>
                      
            </fieldset>
                  
            `})
            export class NewsletterComponent  {

                @Input()
                user: User;

                @Output()
                subscribe = new EventEmitter();

                subscribeToNewsletter(email:string) {
                    this.subscribe.emit(email);
                }

            }

            - Second example with OnPush Change Detection - using same code as above but not mutating the user object directly as we are using OnPush Change Detection


              @Component({
                selector: 'newsletter',
                changeDetection: ChangeDetectionStrategy.OnPush, << OnPush Change Detection Initialised
                template: `...`
              })
              export class NewsletterComponent  {
              ....   same code as above   
              }

              > Home.component.ts
              @Component({
                selector: 'home',
                template: `
                <newsletter [user]="user" (subscribe)="subscribe($event)"></newsletter>
                <button (click)="changeUserName()">Change User Name</button>
            `})
            export class HomeComponent {

                user: User = {
                    firstName: 'Alice',
                    lastName: 'Smith'
                };

                constructor(private newsletterService: NewsletterService) {

                }

                subscribe(email:string) {
                    this.newsletterService.subscribe(email);
                }

                changeUserName() { << not mutating directly. Making a new object so OnPush will work
                  this.user = {
                      firstName: 'Bob',
                      lastName: 'Smith'
                  }
                }
            }

          - Another Example of Implementing OnPush Change Detection (without Observable Courses Data Streams);
            > CourseCard.component.ts
            @Component({
              selector: 'course-card',
              templateUrl: './course-card.component.html',
              styleUrls: ['./course-card.component.css'],
              changeDetection: ChangeDetectionStrategy.OnPush
            })

            @Input() course:Course

            > Edit course (Enforcing immutability without mutating data/objects directly so we can use OnPush change detection)

            App.component.ts
            courses = COURSES;

            constructor() {

            }

            > spread over & copy course to change description property so that the child component CourseCard.component gets the updated values. If we did not spread over and mutate directly the child component would be eliminated from the change detection cycle as we added changeDetection: ChangeDetectionStrategy.OnPush to the courseCard.component
            onEditCourse() {
              const course = this.courses[0];
        
              const newCourse:any = {...course};
          
              newCourse.description = "New Value";
              this.courses[0] = newCourse;
            }
          
          
          - Example of OnPush Change Detection with Observable Data Streams (By using the async pipe with Observables OnPush Change Detection works just fine when new values are emitted. If we subscribed manually in ngOninit onPush would not work);
            
          > CourseCardComponent
          @Component({
            selector: 'course-card',
            templateUrl: './course-card.component.html',
            styleUrls: ['./course-card.component.css'],
            changeDetection: ChangeDetectionStrategy.OnPush
          })
          
          > App component.ts
          courses$: Observable<Course[]>;

          constructor(private coursesService: CoursesService) {

          }

          ngOnInit() {
            this.courses$ = this.courseService.loadCourses()
          }

          > App component.html
          <div class="courses" *ngIf="(courses$ | async) as courses">
            <course-card *ngFor="let course of courses"
                        [course]="course"
                        (courseChanged)="save($event)">
              <course-image [src]="course.iconUrl"></course-image>

            </course-card>
          </div>


        - Custom Change Detection can be implemented to tell angular to looks for changes in particular component when using OnPush change detection if we have not updated the @Input properties with by using the spread operator or when using observables without using the async pipe. Custom change detection is not best practice and should be used only when manually requesting changes frequently, that are expensive - i.e every 2seconds when dealing with lots of data continually.
          
        - Custom Change Detection is Implemented in constructor as private cd: ChangeDetectorRef. We then use ngDoCheck() lifecycle hook and inside this hook we check for changes using this.cd.markForCheck();
        
        - Best way to implement custom change detection is by putting the checking logic in the DoCheck & ngDoCheck() lifecycle hook below:

          courses = Course[];
          loaded:boolean = false;

          constructor(private cd: ChangeDetectorRef){
          }

          ngDoCheck() {
            if(this.loaded) {
              this.cd.markForCheck();
              this.loaded = undefined;
            }
          }

          ngOnInit() {
            this.coursesService.loadCourses().subscribe(courses => {
              this.courses = courses;
            
              this.loaded = true;

            }) 
          }

        - Attribute Decorator can be used when we have lots of inputs passed in to a component that will not require a change in data. So when having lots of @Input() property and we are sure than that data will not change over time we can use the @Attribute('type') private type: string in the constructor. Its great for performance optimization because when Angular runs through the change detection cycle if using the @Attribute decorator it will not check for changes on the @Input property.

        - Attribute decorator implemented as below in the component constructor;
          constructor(@Attribute('type') private type: string)) {

          }

          > Attribute used in component View
          <component type="beginner">

          </component> -->

  <!-- 5 - Component Lifecycle Hooks
      - A component instance has a lifecycle that starts when Angular instantiates the component class and renders the component view along with its child views. The lifecycle continues with change detection, as Angular checks to see when data-bound properties change, and updates both the view and the component instance as needed. The lifecycle ends when Angular destroys the component instance and removes its rendered template from the DOM. Directives have a similar lifecycle, as Angular creates, updates, and destroys instances in the course of execution.

      - Your application can use lifecycle hook methods to tap into key events in the lifecycle of a component or directive to initialize new instances, initiate change detection when needed, respond to updates during change detection, and clean up before deletion of instances. 

      - Respond to events in the lifecycle of a component or directive by implementing one or more of the lifecycle hook interfaces in the Angular core library. The hooks give you the opportunity to act on a component or directive instance at the appropriate moment, as Angular creates, updates, or destroys that instance.

      - You don't have to implement all (or any) of the lifecycle hooks, just the ones you need.

      - After your application instantiates a component or directive by calling its constructor, Angular calls the hook methods you have implemented at the appropriate point in the lifecycle of that instance.
      
      - Angular Component Lifecycle Hooks in the order they are executed:

        - Constructor() gets called first when the component instance is created.
          - Here we declare dependency injection services and OnPush Change Detection 

        - ngOnChanges() lifecycle hook gets called after constructor and before ngOnInit. 
          - It is called when an @Input member variable/binding value changes & gets updated (not mutated directly within a method in the component or directive but can use the spread operator to make a copy of the input and then change the value. This will trigger ngOnChanges()). 
          - When the @Input member variables gets updated the template gets recalculated and the view gets updated.
          - The method receives a 'SimpleChanges' object of current and previous property values (much like in DTO map-wrapper directive)
            - Simple Changes is a hashtable of changes represented by SimpleChange objects stored at the declared property name they belong to on a Directive or Component. This is the type passed to the ngOnChanges hook.
          - The ngOnChanges() method takes an object that maps each changed property name to a SimpleChange object holding the current and previous property values. This hook iterates over the changed properties and logs them.
          - If your component has no inputs or you use it without providing any inputs, the framework will not call ngOnChanges().
          - If using spread operator to mutate the @Input member variables it does work.
          - Useful is you want to call a callback function when data has changed.
          - Code example - https://angular.io/guide/lifecycle-hooks#onchanges

        - ngOnInit() gets called after the first ngOnChanges hook once when the component is first initialized. 
          - Called once, after the first ngOnChanges(). ngOnInit() is still called even when ngOnChanges() is not (which is the case when there are no template-bound inputs).
          - Initialize the directive or component after Angular first displays the data-bound properties and sets the directive or component's input properties. See details in Initializing a component or directive in this document.
          - We can use this for example to call a function that loads some data - course data in the example of Angular University Course.
          - ngOnInit is a good place for a component to fetch its initial data.

        - ngDoCheck() is called after every Change Detection run. 
          - Called immediately after ngOnChanges() on every change detection run, and immediately after ngOnInit() on the first run.
          - It is used to Detect and act upon changes that Angular can't or won't detect on its own. See details and example in Defining custom change detection in this document.
          - ngDoCheck() is used when implementing Custom onPush Change Detection and is placed between the constructor and ngOnInit
          - See above OnPush Change Detection notes for code example.

        - ngAfterContentInit() gets called after every check of component content is antialiased. 
          - Its called once after the first ngDoCheck()
          - Respond after Angular projects external content into the component's view, or into the view that a directive is in.
          - Use case would be to project external content into a component and how to distinguish projected content from a component's view children. Demonstrates the ngAfterContentInit() and ngAfterContentChecked() hooks.
        
        - ngAfterContentChecked() gets called after very check of a components content, when content of the component gets projected the the UI and checked. 
          - Called after ngAfterContentInit() and every subsequent ngDoCheck().
          - Its purpose is to Respond after Angular checks the content projected into the directive or component.
          - @Input data properties can be mutated in this function in some cases.
        
        - ngAfterViewInit() gets called after a components views (parent/child) are antialiased.
          - Called once after the first ngAfterContentChecked().
          - Its purpose is to respond after Angular initializes the component's views and child views, or the view that contains the directive.
          - ngAfterViewInit is related to content projection
          - ngAfterViewInit is related local template querying 

        - ngAfterViewChecked() gets called after every check of a components views.
          - Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked(). 
          - Its purpose is to respond after Angular checks the component's views and child views, or the view that contains the directive.
          - Can't modify @Input data at this point. Main use case is to perform common DOM operations such as scroll to the bottom of a screen after components has finished running through the prior lifecycle methods, focus on DOM element.

        - ngOnDestroy() gets called when the components gets destroyed. 
          - Called immediately before Angular destroys the directive or component.
          - Its purpose is to cleanup just before Angular destroys the directive or component. Unsubscribe Observables and detach event handlers to avoid memory leaks. 
          - Great way to clean up any resources that the component is using i.e Observable data streams
          - If using async pipe with Observable, ngOnDestroy() is not needed to unsubscribe from the observable as the async pipe does this automatically.
        
      - Component Lifecycle Hooks Resources:
        - Angular Docs - https://angular.io/guide/lifecycle-hooks
        - Angular Training Guide - https://angular-training-guide.rangle.io/advanced-components/component_lifecycle  
        - Angular Uni - https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/ 
        - Angular Uni - https://blog.angular-university.io/onpush-change-detection-how-it-works/ -->

  <!-- 4 - Services & Dependency Injection 
      - Dependency Injection allows us to inject a service anywhere win the application
      - Consider use cases for app wide specific services (http, auth, api data)
      - Service methods working with class methods (service methods to speak with backend, component methods to update class properties and UI)
      - Best Practices.....
      - Application Service Singleton concepts - when a services is provided at the root of the application and therefore can be used application wide using Dependency Injection
      - Singleton Dependency Injection enables us to use the concept of 'Tree Shakable Providers' which should be used in most cases unless a specific components has state and we want to inject a service to that s single component and not the 'root' of the app
      - @Self Decorator can be used to apply a a service for only a single component
      - @Host Decorator can be used to apply a single instance of of a service to custom directive - Much like the highlighted directive created in the deep dive course 

      - Angular Uni Blog Resource
        - https://blog.angular-university.io/angular-dependency-injection/ --> 

  <!-- 5 - Pipes 
      - Angular has built in pipes(below) and custom pipes can also be created 
      - currency, number, async, date, text formatting, json, formatting collections of data
            
      EXAMPLE (Built in pipes):
              
            <div class="demo">
              <div>
                  Date pipe with date output formatting  
                  Start Date: {{ startDate | date: 'MMM/dd/yyyy' }}
              </div>
              <div>
                  text formatting pipe
                  {{ title | uppercase }}
              </div>
              <div>
                  Number formatting pipe
                  {{ price | number: '3.3-5' }}
              </div>
              <div>
                  Currency formatting pipe
                  {{ price | currency: 'EUR' }}
              </div>
              <div>
                  Currency formatting pipe
                  {{ rate| percent }}
              </div> 

              JSON pipe
              <div>
                  {{ courses | json }}
              </div> 

              Key value pair pipe for object data
              <div *ngFor="let pair of course | keyvalue">
                  {{pair.key + ': ' + pair.value}}
              </div>
            </div> 

      - Custom pipes can be created with file name, within a feature module - filter-by-category.pipe.ts
      - Custom pipes should also be exported out of a feature module that they are located in
            - EXAMPLE Custom Pipe;

            ** FilterByCategory.pipe.ts:

            import { Pipe, PipeTransform } from "@angular/core";
            import { Course } from "../model/course";

            @Pipe({
              name: 'filterByCategory'
            })
            export class FilterByCategory implements PipeTransform {

              transform(courses: Course[], category: string) {
                return courses.filter(course => course.category === category);
              }
            
            }

            ** App.component.html:

            <div class="courses" *ngIf="(courses$ | async | filterByCategory: 'BEGINNER') as courses">
              <course-card *ngFor="let course of courses"
                          [course]="course"
                          (courseChanged)="save($event)">
                <course-image [src]="course.iconUrl"></course-image>

              </course-card>
            </div>

      - Pure pipes can be used in an instance were a course category data may change although with the above custom pipe it will not be filtered from the UI
      - Angular does not trigger a pure pipe to re run on every change detection cycle as it can be expensive (pure pipes are best practice)
      - Impure pipes can be used were we want the pipe to be called in every change detection cycle (can be expensive so best practice is to use pure pipes)
          - Impure pipe implementation
            EXAMPLE:

            ** FilterByCategory.pipe.ts:
            @Pipe({
              name: 'filterByCategory',
              pure: false
            })
   
  6 - Routing
      - Page routing with component
      - Dynamic route data using ParamMap(/:id)
      - Child Routes
      - Protected routes using Guards()
      - Lazy Loading Feature Modules with Routing
      - routerLink="/courses" is used on <a> tag links to link to a route 

  7 - Modules / NgModules
      - App.module.ts is the root module
        - Declarations: (components, directives)
        - Imports: (BrowserModule, HttpClient, BrowserAnimationsModule, feature modules )
        - Providers: (Services)
        - bootstrap: (AppComponent)
      - Pipes, services & custom directives can be applied to a shared module / feature module. 
      - Feature Modules can be create with ng generate module courses to group tightly related components, services, directives & pipes (large applications)
        - The course module is an example that would include all the course related components, services, directives & pipes
        - Feature modules can include components, services, directives, pipes 
        - All feature modules must include CommonModule
        - Feature modules must have exports to allow the root module to understand that we want to use this modules components: [CourseCardComponent, CourseImageComponent]
        - ** Remember to refactor all the necessary imports, declarations etc when refactoring a feature module
      - Feature Module Lazy Loading with Routes
      - As well as feature modules we can have shared modules 
      - Angular Uni & Docs Blog Resource
        - https://blog.angular-university.io/angular2-ngmodule/
        - https://angular-training-guide.rangle.io/modules
        - https://angular.io/guide/feature-modules

  8 - Angular Internationalization
        - Enables us to make the app multi language 
        - i18n can be places on a element as a custom attribute to implement internationalization then run 'ng xi18n' in terminal which will create a message.xlf file
          - Example: <button (click)="onEditCourse()" i18n>Edit Course</button>
        - The the message.xlf file an 'id' is generated for the element we market with 'i18n' and is passed through translator 
        - i18n-"welcome" can be used giving the translation context in cases were a words are interpreted different in other languages - this is passed to the translator to help it translate the element
        - i18n also supports pluralization support - can use a member variable to do so - i.e courseTotal = 18
        - i18n also supports Expression support
        - ng xi18n --i18n-locale fr in the terminal to change the language in the message.xlf file 
        - Locale will be a folder in the app to house all of the translated files

  9 - Angular Elements
      - Angular elements are used in in circumstances for example a CMS were the user wants to create their own content within the application

  10 - Observables & RxJS Library
      - RxJS is a library for composing asynchronous and event-based programs by using observable sequences.
      - GitHub Links for course specific notes:
        - RxJs in Practice Course: https://github.com/clarkenewsh/angular-rxjs-in-practice-subjects-storePattern/blob/main/rxjsInPracticeCourseNotes.md
      - Learning Resource 
        - Angular Uni Youtube
        - Ng-Conf Youtube
        - Decoded Frontend Youtube
        - Angular Uni Blog 
          - RxJs and Observables for Beginners: https://blog.angular-university.io/functional-reactive-programming-for-angular-2-developers-rxjs-and-observables/
          - RxJs Blog Articles - https://blog.angular-university.io/tag/rxjs/

  11 - Reactive Angular In Practice
      - See course notes for how to to apply reactive patterns to Angular apps (stateless observable service, Reactive Component Interaction, Auth State Management, Master Detail UI Pattern, Single Data Observable Pattern)
      - Reactive Angular Course: https://github.com/clarkenewsh/reactive-angular-with-rxjs/blob/main/reactiveAngularCourseNotes.md
      - Learning Resource:
        - Angular Uni Youtube
        - Ng-Conf Youtube
        - Decoded Frontend Youtube
        - Angular Uni Blog 
          - RxJs and Observables for Beginners: https://blog.angular-university.io/functional-reactive-programming-for-angular-2-developers-rxjs-and-observables/
          - RxJs Blog Articles - https://blog.angular-university.io/tag/rxjs/
  
  12 - Animations 
      - ng module for animation library

  13 - Angular Material
        - Angular Uni Blog Resource:
          - https://blog.angular-university.io/tag/angular-material/

  14 - Testing 
      - Unit
      - End-to-end

  15 - Best Practices 
      - Large scale applications & architecture 
      - Security
      - Accessibility 
      - Lazy Loading Feature Modules
      - Property Binding Best Practice 
      - Keeping up to date 
  
  16 - TypeScript
        - Resource to look at to take notes
        - TS Docs https://www.typescriptlang.org/docs/handbook/intro.html
        - Angular Uni Blog - https://blog.angular-university.io/tag/typescript/
        - Angular Uni YouTube 
        - Angular Guide - https://angular-training-guide.rangle.io/features/typescript

        - Concepts to concentrate on
          - Classes
          - Enums
          - Interfaces
          - Primitive Types & type annotations
          - Parameter types
          - Function return types
          - Generic types
          - Partials
          - Unions
          - Object Destructuring 
          - Tuples
          - Getters/setters
          - Partials
          - Private/public 
  
  16 - SASS
        - Sass Docs - https://sass-lang.com/guide

        - Variables:
          - Think of variables as a way to store information that you want to reuse throughout your stylesheet. You can store things like colors, font stacks, or any CSS value you think you'll want to reuse. Sass uses the $ symbol to make something a variable. 
          - Here's an example:
            SCSS SYNTAX
            $font-stack: Helvetica, sans-serif;
            $primary-color: #333;

            body {
              font: 100% $font-stack;
              color: $primary-color;
            }

        - Nesting:
              - When writing HTML you've probably noticed that it has a clear nested and visual hierarchy. CSS, on the other hand, doesn't.Sass will let you nest your CSS selectors in a way that follows the same visual hierarchy of your HTML. Be aware that overly nested rules will result in over-qualified CSS that could prove hard to maintain and is generally considered bad practice. With that in mind, here's an example of some typical styles for a site's navigation:
              - Example:
              nav {
                ul {
                  margin: 0;
                  padding: 0;
                  list-style: none;
                }

                li { display: inline-block; }

                a {
                  display: block;
                  padding: 6px 12px;
                  text-decoration: none;
                }
              }


        - Partials:
          - You can create partial Sass files that contain little snippets of CSS that you can include in other Sass files. This is a great way to modularize your CSS and help keep things easier to maintain. A partial is a Sass file named with a leading underscore. You might name it something like _partial.scss. The underscore lets Sass know that the file is only a partial file and that it should not be generated into a CSS file. Sass partials are used with the @use rule.


        - Mixins:
          - Some things in CSS are a bit tedious to write, especially with CSS3 and the many vendor prefixes that exist. A mixin lets you make groups of CSS declarations that you want to reuse throughout your site. It helps keep your Sass very DRY. You can even pass in values to make your mixin more flexible. Here's an example for theme.

          - Example: 
          SCSS SYNTAX
          @mixin theme($theme: DarkGray) {
            background: $theme;
            box-shadow: 0 0 1px rgba($theme, .25);
            color: #fff;
          }

          .info {
            @include theme;
          }
          .alert {
            @include theme($theme: DarkRed);
          }
          .success {
            @include theme($theme: DarkGreen);
          }

        - Modules:
          - You don't have to write all your Sass in a single file. You can split it up however you want with the @use rule. This rule loads another Sass file as a module, which means you can refer to its variables, mixins, and functions in your Sass file with a namespace based on the filename. Using a file will also include the CSS it generates in your compiled output! Notice we're using @use 'base'; in the styles.scss file. When you use a file you don't need to include the file extension. Sass is smart and will figure it out for you. 

          Example: 
          SCSS SYNTAX
          * _base.scss
          $font-stack: Helvetica, sans-serif;
          $primary-color: #333;

          body {
            font: 100% $font-stack;
            color: $primary-color;
          }

          * styles.scss
          @use 'base';

          .inverse {
            background-color: base.$primary-color;
            color: white;
          }

        - Extend/Inheritance:
          - Using @extend lets you share a set of CSS properties from one selector to another. In our example we're going to create a simple series of messaging for errors, warnings and successes using another feature which goes hand in hand with extend, placeholder classes. A placeholder class is a special type of class that only prints when it is extended, and can help keep your compiled CSS neat and clean. What the below code does is tells .message, .success, .error, and .warning to behave just like %message-shared. That means anywhere that %message-shared shows up, .message, .success, .error, & .warning will too. The magic happens in the generated CSS, where each of these classes will get the same CSS properties as %message-shared. This helps you avoid having to write multiple class names on HTML elements. You can extend most simple CSS selectors in addition to placeholder classes in Sass, but using placeholders is the easiest way to make sure you aren't extending a class that's nested elsewhere in your styles, which can result in unintended selectors in your CSS. Note that the CSS in %equal-heights isn't generated, because %equal-heights is never extended.
 
          - Example: 
            /* This CSS will print because %message-shared is extended. */
          %message-shared {
            border: 1px solid #ccc;
            padding: 10px;
            color: #333;
          }

          // This CSS won't print because %equal-heights is never extended.
          %equal-heights {
            display: flex;
            flex-wrap: wrap;
          }

          .message {
            @extend %message-shared;
          }

          .success {
            @extend %message-shared;
            border-color: green;
          }

          .error {
            @extend %message-shared;
            border-color: red;
          }

          .warning {
            @extend %message-shared;
            border-color: yellow;
          }

          
          - Operators:
            - Doing math in your CSS is very helpful. Sass has a handful of standard math operators like +, -, *, math.div(), and %. In our example we're going to do some simple math to calculate widths for an article and aside.

            - Example: 
             @use "sass:math";

            .container {
              display: flex;
            }

            article[role="main"] {
              width: math.div(600px, 960px) * 100%;
            }

            aside[role="complementary"] {
              width: math.div(300px, 960px) * 100%;
              margin-left: auto;
            }

          -->


<h1>{{title}}</h1>

<app-reactive-forms></app-reactive-forms>

<app-template-driven-form></app-template-driven-form>

