<!-- TASK LIST:

  1 - Forms 
      - Reactive Form to update data ([formGroup]="someForm" <input formControlName="name"> (ngSubmit)="onSubmit()" / name = FormControl('') [formControl]="name" / FormBuilder) - suitable for larger, complex forms
      - Template Driven Form to update data model - ([ngModel]) to bind form data to model <form #someForm="ngForm" (ngSubmit)="onSubmit()"- suitable for small forms
      - Input, two way data binding (ngModel) - <input ([ngModel])="object.name">
      - Form Validation using both reactive & template driven forms, much like html form validation
        - Template Driven Form Validation: (<input required>, <input minlength="2">, <input maxlength="10">, <input pattern="[a-z]+"). Validation message like this: <div *ngIf="name.invalid && (name.dirty || name.touched)><div *ngIf="name.errors?.required"><p>Name is required</p></div>"
        - Reactive Form Validation: someForm = new FormGroup({ name: new FormControl this.nameInput, Validators.required, Validation.minLength(4)}). Validation message like this: <div *ngIf="name.invalid && (name.dirty || name.touched)><div *ngIf="name.errors?.required"><p>Name is required</p></div>"

  2 - Components
      - Text Interpolation from class properties values
      - Parent/Child components @Input for data binding & @Output for event binding/emitting
      - Structural directives (*ngFor, *ngIf)
      - Attribute, class & style directives for dynamic styling (NgModel, NgClass, NgStyle). <h1>[ngClass]="isactive ? 'activeClass' : '' "</h1>
      - Template variables using, #name <input (click)="updateName(name.value)">

  3 - HTTP Client
      - HttpClient service 
      - GET, POST, PUT, DELETE 

        - example get request: 

          http option headers (used for update, add, delete & api key ):
          httpOptions = {
            headers: new HttpHeaders({ 'Content-Type': 'application/json' })
          };

          Service file (responsible for communication with http protocol / backend)
          getData():Observable {
            return this.http.get('https://someurl.com')
            .pipe(catchError (
              (error) => {
                console.log(error);
                return throwError('Error')
              }
            ));
          }

          Component file (responsible for updating class properties & the UI)
          ngOnInit() {
            this.dataService.getData().subscribe((res) => {
              console.log(res);
            })
          }

      - Observables in service
      - Subscribe in component class
      - Error handling using pipe, tap & catchError in service
      - In Memory Data Service for fake REST API Backend
      - Service methods to speak with backend, component methods to update class properties and UI
    
  4 - Services & Dependency Injection 
      - Consider use cases for app wide specific services (http, auth, api data)
      - Service methods working with class methods (service methods to speak with backend, component methods to update class properties and UI)

  5 - Pipes 
      - currency, async, date, format, json
 
  6 - Routing
      - Page routing with component
      - Dynamic route data using ParamMap(/:id)
      - Child Routes
      - Protected routes using Guards()

  7 - Animations 
      - ng module for animation library

  8 - Testing 
      - Unit
      - End-to-end

-->


<h1>{{title}}</h1>

