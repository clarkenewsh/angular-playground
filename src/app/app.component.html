<!-- TASK LIST:

  1 - Forms 
      - Reactive Form to update data ([formGroup]="someForm" <input formControlName="name"> (ngSubmit)="onSubmit() name: new FormControl('')" / name = new FormControl('') [formControl]="name" / FormBuilder) - suitable for larger, complex forms
      - Template Driven Form to update data model - ([ngModel]) to bind form data to model <form #someForm="ngForm" (ngSubmit)="onSubmit()"- suitable for small forms
      - Input, two way data binding (ngModel) - <input ([ngModel])="object.name">
      - Form Validation using both reactive & template driven forms, much like html form validation
        - Template Driven Form Validation: (<input required>, <input minlength="2">, <input maxlength="10">, <input pattern="[a-z]+"). Validation message like this: <div *ngIf="name.invalid && (name.dirty || name.touched)><div *ngIf="name.errors?.required"><p>Name is required</p></div>"
        - Reactive Form Validation: someForm = new FormGroup({ name: new FormControl this.nameInput, Validators.required, Validation.minLength(4)}). Validation message like this: <div *ngIf="name.invalid && (name.dirty || name.touched)><div *ngIf="name.errors?.required"><p>Name is required</p></div>"

  2 - Components / core directives
      - Text Interpolation from class properties values
      - Parent/Child components @Input for data binding & @Output for event binding/emitting
      - Structural directives (*ngFor, *ngIf, ngContainer(used when we need a div to conditionally render html structure), *ngSwitchCase elvis operator?, index, ng-template to show error messages, conditional html structure, conditional classes)
      - Attribute, class & style directives for dynamic styling (NgModel, NgClass, NgStyle, ngSwitch). <h1>[ngClass]="{isActive ? 'activeClass' : '' }"</h1>
          - Conditional classes and element styles can also be implemented using a method [ngClass]="cardClasses()" or [ngStyle]="cardStyles()" - (keeps the view clean) to check the key value pairs of the object are true/false, apply classes based out outcome.
            Example: 
                cardClasses() {
                  if(this.course.category == 'BEGINNER') {
                      return 'beginner';
                    }
                  }
      - Template variables using, #name <input (click)="updateName(name.value)">
      - Template Querying: viewChild & viewChildren - get a reference to the component 
          - @ViewChild(CourseCardComponent) card: CourseCardComponent;
          - @ViewChild('container') containerDiv: ElementRef; View Child Decorator - get html element reference object
          - @ViewChild('container', {read: ElementRef}) containerDiv: ElementRef; - View Child Decorator - get html element in relation to the html DOM element (not component)
      - Lifecycle Hooks
          - ngAfterViewInit
          - 
      - Custom Directives (can create custom directives that can be applied to components as attributes/classes/events/structural directives. Use case is to make re-usable custom directives class, attribute and events that can then be applied throughout to app by adding to components)
          - Custom Directives stored in 'directives folder'
          - Apply highlighted directive to className DOM property using @HostBinding (must be a known DOM property)
          - Apply to DOM attr directly instead of DOM Property
          - @HostListener is used to interact with native DOM Events i.e mouseover / mouseleave / (use case - create custom events)
                  - Can also used to emit custom $event 
          - Custom structural directives
                  -*ngxUnless (does the opposite to *ngIf) if the value is falsey
                  - *ngx means custom 
      - View encapsulation concept is what happens under the hood when we have a css file scoped to an individual component   
          - :host can be used to app style the the host component 
          - ::ng-deep used to bypass view encapsulation (use case is to style elements within a component that have used content projection)
          - :host-context Modifier 
          - Bypass the feature encapsulation using: ViewEncapsulation.None 

  3 - HTTP Client
      - HttpClient service 
      - GET, POST, PUT, DELETE 
      - Async pipe as a solution to unsubscribe from a http observable (reduce memory leak)
      - Observables & RxJs
      - Observables in service
      - Subscribe() in component class
      - Error handling using pipe, tap & catchError in service
      - In Memory Data Service for fake REST API Backend
      - Service methods to speak with backend, component methods to update class properties and UI
      - Async pipe - A better way of passing Observable data to a view

        - Example get request: 

        http option headers (used for update, add, delete & api key ):
        httpOptions = {
          headers: new HttpHeaders({ 'Content-Type': 'application/json' })
        };

        ***SOLUTION 1 (Angular docs example with error handling)
        Service file (responsible for communication with http protocol / backend)
        getData():Observable {
          return this.http.get('https://someurl.com')
          .pipe(catchError (
            (error) => {
              console.log(error);
              return throwError('Error')
            }
          ));
        }

        Component file (responsible for updating class properties & the UI)
        ngOnInit() {
          this.dataService.getData().subscribe((res) => {
            console.log(res);
          })
        }


        ***SOLUTION 2 (Angular University example)
        // Call http service upon component initialization
          ngOnInit() {

            this.http.get('/api/courses')
            .subscribe(
              val => console.log(val);
            );
          }

        ***SOLUTION 2 with custom params (Angular University example)
          // Call http service upon component initialization
            ngOnInit() {

              // Set custom params (first page, first 10 courses)
              const params = new HttpParams()
              .set("page", "1")
              .set("pageSize", "10");

              this.http.get('/api/courses', {params})
              .subscribe(
                courses => this.courses = courses;
              );
            }

           ***SOLUTION 3 - Defining Observable as a variable and use the async pipe to subscribe to observable (best practice) 
              // Define courses Observable - value returned, array of courses
              courses$: Observable<Course[]>

              // HTTP Get request using the course Observable variable courses$ : Observable<Course[]>
              this.courses$ = this.http.get<Course[]>('/api/courses', {params});

              // Take courses Observable and subscribe to it using the async pipe (async pipe will take take of unsubscribing from the Observable when component gets destroyed) -->
              <!-- <div class="courses" *ngIf="courses$ | async as courses">
                <course-card *ngFor="let course of courses"
                            [course]="course">

                  <course-image [src]="course.iconUrl"></course-image>

                </course-card>

              </div> -->


    
  4 - Services & Dependency Injection 
      - Consider use cases for app wide specific services (http, auth, api data)
      - Service methods working with class methods (service methods to speak with backend, component methods to update class properties and UI)
      - Best Practices

  5 - Pipes 
      - currency, number, async, date, text formatting, json, formatting collections of data
 
  6 - Routing
      - Page routing with component
      - Dynamic route data using ParamMap(/:id)
      - Child Routes
      - Protected routes using Guards()
      - Lazy Loading Feature Modules with Routing 

  7 - NgModules
      - httpClient Module
      - Form Module
      - Feature Modules (large applications)
      - Feature Module Lazy Loading with Rxutes

  8 - Observables & RxJS


  9 - Animations 
      - ng module for animation library

  10 - Testing 
      - Unit
      - End-to-end

  11 - Best Practices 
        - Large scale applications & architecture 
        - Security
        - Accessibility 
        - Lazy Loading Feature Modules
        - Property Binding Best Practice 
        - Keeping up to date 
        

-->


<h1>{{title}}</h1>

<app-reactive-forms></app-reactive-forms>

<app-template-driven-form></app-template-driven-form>

